### Hi there ðŸ‘‹


## What is this user/user repo about
I am currently studying (and iterating) how to build a system that shows the underlying design decisions explicit to their output, their inference to a set of viable solutions to comply with sets of requirements, aimed to assist design endeavors from a white-box approach (both deterministic and probabilistic).  

<details>
  <summary><strong>Base Research Question: Can a design be explicit in its measured sources of decision?</strong></summary>
It is an idea IÂ´ve been working on from some time ago, and for the moment the hypotheses hold against simple scripts, but I would like to open the concept basis to complexity testing.  
In some more weeks I might have some parts uploaded here (instead of being drawings at a portfolio of works).  
</details>

*Note: In the meantime, I will be using this username instead of my full name. Consider these notes and files empirically sourced.*   

## Why this will be useful?
I (naively) plan to build a library/module to contain a explicit design process that can be weighted with ai.  
Having a explicit design approach could help with the decision methods during the stages of development.  
That is the long term goal. At least if I die of whatever the concept could float away.  â€ƒ
â€ƒ  
I am working in this concept:
<details>
  <summary><strong>When is a design a good one?</strong></summary>
Formally, a design is a method of communication between Sender and Receiver, crafted with a purpose.  
It is "good" or "bad" depending on whether the Receiver perceiving it can read the ideas intended to communicate from Sender, by evaluating the properties expressed in it.  
This judgement happens within a comparative evaluation at the Receiver side.

The Receiver, when perceiving the design, compares it with one already stored in memory that corresponds to the subject associated with it.  
Then wonders:  

*"Does this proposal needs changes to express better such an idea than the solution I remember that already works?"*

If it answers NO, then the evaluation stops.
What the Receiver remembers does not need any more changes.
As a result, the design is ugly, wrong, whimsical.

If it answers YES, the Receiver is open to modifying the solution in its memory and starts looking for properties.
The evaluation continues.

The (human) brain evolved searching for events that repeat themselves following an order, patterns, sequences that could simplify reality.

* Reality: the set of all existing data  
* Senses: the enabled capabilities  
* Memory: what is stored and associated  
* Model: simplified reality  

In the local environment, the sequences exist without differentiation.
The available senses reduce the complexity of reality and make it processable as a local model by detecting measurable events, thus differentiating each one as properties, and events get defined by their perceived values.

Then these pairs of property and value are allocated into memory if required, based on the priority of use or association. Properties get measured according to the value they appear to be worth.
With the property-value pairs in memory, the brain builds and stores a quick access tool to be used when the situation requires it.
</details>
<details>
  <summary><strong>Concept: The narrative of design</strong></summary>
How the brain parses these sequences correspond to a process of invention, from which are developed tools and processes.  
This composition gets communicated as a narrative of properties and values.  
If the Receiver is capable to perceive as intended the narrative of the design, then the design will get evaluated as good.  

An invention process would be:
* Step 1: Mathematics. Quantification of reality, relationships, concepts of measure, properties of numbers, and proportions. The proposition of ideas as logic constructs.
* Step 2: Language. Ideas get packaged into words, meanings.
* Step 3: Architecture. Structure of requirements of an idea, relationships, properties, and values required in elements that will be transmitted. Define and compose the methods that are available for communicating the idea to the Receiver.
* Step 4: Design. The planning on how to make and deliver something. Configuration of assembly, function, shape, methods.
* Step 5: Delivery. Ability to do, technique, art. Expression, implementation of the idea as a narrative from the design, delivered as a memory message to the Receiver, who as perceives the design deploys the idea into its comparative evaluation. 
</details>
<details>
  <summary><strong>Pieces</strong></summary>
* There should be a sense templating system  
* There should be something like an UI (for monitoring, for moving things, for inputs, etc)  
* There should be a system to show the n-dimension tree of 'truths' with the outputs  
* There should be some models for the intelligences to deploy (senses, memory, logic)
* There should be a system to deploy all pieces to get sensed and processed 
</details>

## About contributions
It is a bit early to ask for any.
â€ƒ
## License
The software in the projects (TBA) are licensed under the [MIT License](https://github.com/virtknois/virtknois/blob/main/LICENSE)  
The not-software content, like essays, theory, images, databases, etc, are under the [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)  

## My background
<details>
  <summary>Related currently studying</summary>
* Learning frontend at Scrimba (html, css, javascript, react), because cli scripts are too arid  
* Leveraging: git, data structures, algorithms, python3, design bits I learned from architecture school and practice
* Starting with gcloud and azure, databases, java (core)
</details>
<details>
  <summary>Previous</summary>
I have a Bsc in Architecture (UTFSM, Chile), and I know how to code headless cli scripts with python3 and bash, both in MS Windows and Debian. I *mained* Autocad then Revit then Blender, and had to implement ideas there before, which prompted me into coding outside of those tools.  
Other skills besides playing with machines are: I know SMAW and MIG/MAG welding, carpentry, laying concrete, how to install solar panel systems, and how to grow vegetables. Those are kind of related because processes follow their own algorithms.
</details>






